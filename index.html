
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>hasBrain Tracker</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,300,500,700' rel='stylesheet' type='text/css'>
  <style type="text/css">
  	.node {
        cursor: pointer;
    }

    .overlay{
        background-color:#EEE;
    }

    .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 1.5px;
    }

    .node text {
        font-size:10px; 
        font-family:sans-serif;
    }

    .link {
        fill: none;
        stroke: rgb(122, 163, 229);
        stroke-width: 3.5px;
    }

    .templink {
        fill: none;
        stroke: red;
        stroke-width: 3px;
    }

    .ghostCircle.show{
        display:block;
    }

    .ghostCircle, .activeDrag .ghostCircle{
       display: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="learning-tree1"></div>
  <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
  <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
  <script type="text/javascript" src="https://cdn.pubnub.com/pubnub-3.7.18.min.js"></script>
  <script src="app.js"></script>
  <script type="text/javascript">
  		$( document ).ready(function() {
	        var treeData = {"name":"#learning-tree1", "children" : [{"_id":"5737655c1211ab850698a90a","slug":"javascript-fundamental","name":"Javascript Fundamental","cover":{"url":"http://www.crossmediaconsultancy.co.uk/wp-content/uploads/2015/09/javascript-logo-banner.jpg"},"nodeType":"course","children":[{"_id":"5737655c1211ab850698a90b","slug":"arguments","tester":"https://circleci.com/api/v1/project/ToanNG/node-test/tree/master?circle-token=1e0d54eafd8f594f7be72999699f005fa2a06a33","no":1,"estimation":1,"knowledge":"<p>The arguments object is an Array-like object corresponding to the arguments passed to a function. It is similar to an Array, but does not have any Array properties except length. However it can be converted to a real Array:</p><pre><code class=\"language-javascript\">var args = Array.prototype.slice.call(arguments);</code></pre><p>Watch the following video for more details</p><p><iframe src=\"https://www.youtube.com/embed/cBzwch3mqxA\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\"></iframe></p>","problem":"<p>Implement a function that returns the sum of its parameters. For example:</p> <pre><code class=\"language-javascript\">sum(2, 4, 6) // =&gt; 12</code></pre> <p>You can get the code boilerplate <a href=\"#\">here</a>.</p>","description":"Learn what argument is in Javascript.","name":"Arguments","nodeType":"activity","parent":"5737655c1211ab850698a90a","children":[]},{"_id":"5737664a1211ab850698a910","slug":"closure","parent":"5737655c1211ab850698a90a","name":"Closure","nodeType":"activity","description":"","knowledge":"","no":4,"problem":"","tester":"","children":[]},{"_id":"573766261211ab850698a90d","slug":"data-structures","parent":"5737655c1211ab850698a90a","name":"Data Structures","nodeType":"course","cover":{"url":"http://www.crossmediaconsultancy.co.uk/wp-content/uploads/2015/09/javascript-logo-banner.jpg"},"description":"","children":[{"_id":"573766301211ab850698a90e","slug":"object","parent":"573766261211ab850698a90d","name":"Object","nodeType":"activity","description":"","knowledge":"","no":2,"problem":"","tester":"","children":[]},{"_id":"5737663c1211ab850698a90f","slug":"array","parent":"573766261211ab850698a90d","name":"Array","nodeType":"activity","description":"","knowledge":"","no":3,"problem":"","tester":"","children":[]}]}]}]};

	        // Calculate total nodes, max label length
	        var totalNodes = 0;
	        var maxLabelLength = 0;
	        // variables for drag/drop
	        var selectedNode = null;
	        var draggingNode = null;
	        // panning variables
	        var panSpeed = 200;
	        var panBoundary = 20; // Within 20px from edges will pan when dragging.
	        // Misc. variables
	        var i = 0;
	        var duration = 750;
	        var root;

	        // size of the diagram
	        var viewerWidth = $(document).width();
	        var viewerHeight = $(document).height();

	        var tree = d3.layout.tree()
	            .size([viewerHeight, viewerWidth]);

	        // define a d3 diagonal projection for use by the node paths later on.
	        var diagonal = d3.svg.diagonal()
	            .projection(function(d) {
	                return [d.y, d.x];
	            });

	        // A recursive helper function for performing some setup by walking through all nodes

	        function visit(parent, visitFn, childrenFn) {
	            if (!parent) return;

	            visitFn(parent);

	            var children = childrenFn(parent);
	            if (children) {
	                var count = children.length;
	                for (var i = 0; i < count; i++) {
	                    visit(children[i], visitFn, childrenFn);
	                }
	            }
	        }

	        // Call visit function to establish maxLabelLength
	        visit(treeData, function(d) {
	            totalNodes++;
	            maxLabelLength = Math.max(d.name.length, maxLabelLength);

	        }, function(d) {
	            return d.children && d.children.length > 0 ? d.children : null;
	        });


	        // sort the tree according to the node names

	        function sortTree() {
	            tree.sort(function(a, b) {
	                return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;
	            });
	        }
	        // Sort the tree initially incase the JSON isn't in a sorted order.
	        sortTree();

	        // Define the zoom function for the zoomable tree

	        function zoom() {
	            svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
	        }


	        // define the zoomListener which calls the zoom function on the "zoom" event constrained within the scaleExtents
	        var zoomListener = d3.behavior.zoom().scaleExtent([0.1, 3]).on("zoom", zoom);


	        // define the baseSvg, attaching a class for styling and the zoomListener
	        var baseSvg = d3.select("#learning-tree1").append("svg")
	            .attr("width", viewerWidth)
	            .attr("height", viewerHeight)
	            .attr("class", "overlay")
	            .call(zoomListener);


	        // Function to update the temporary connector indicating dragging affiliation
	        var updateTempConnector = function() {
	            var data = [];
	            if (draggingNode !== null && selectedNode !== null) {
	                // have to flip the source coordinates since we did this for the existing connectors on the original tree
	                data = [{
	                    source: {
	                        x: selectedNode.y0,
	                        y: selectedNode.x0
	                    },
	                    target: {
	                        x: draggingNode.y0,
	                        y: draggingNode.x0
	                    }
	                }];
	            }
	            var link = svgGroup.selectAll(".templink").data(data);

	            link.enter().append("path")
	                .attr("class", "templink")
	                .attr("d", d3.svg.diagonal())
	                .attr('pointer-events', 'none');

	            link.attr("d", d3.svg.diagonal());

	            link.exit().remove();
	        };

	        // Function to center node when clicked/dropped so node doesn't get lost when collapsing/moving with large amount of children.

	        function centerNode(source) {
	            scale = zoomListener.scale();
	            x = -source.y0;
	            y = -source.x0;
	            x = x * scale + viewerWidth / 2;
	            y = y * scale + viewerHeight / 2;
	            d3.select('g').transition()
	                .duration(duration)
	                .attr("transform", "translate(" + x + "," + y + ")scale(" + scale + ")");
	            zoomListener.scale(scale);
	            zoomListener.translate([x, y]);
	        }

	        // Toggle children on click.
	        function callback(nodeID){
	            console.log(nodeID);
	        }

	        function click(d) {
	            if (d3.event.defaultPrevented) return; // click suppressed
	            callback(d._id);
	        }

	        function update(source) {
	            // Compute the new height, function counts total children of root node and sets tree height accordingly.
	            // This prevents the layout looking squashed when new nodes are made visible or looking sparse when nodes are removed
	            // This makes the layout more consistent.
	            var levelWidth = [1];
	            var childCount = function(level, n) {

	                if (n.children && n.children.length > 0) {
	                    if (levelWidth.length <= level + 1) levelWidth.push(0);

	                    levelWidth[level + 1] += n.children.length;
	                    n.children.forEach(function(d) {
	                        childCount(level + 1, d);
	                    });
	                }
	            };
	            childCount(0, root);
	            var newHeight = d3.max(levelWidth) * 25; // 25 pixels per line  
	            tree = tree.size([newHeight, viewerWidth]);

	            // Compute the new tree layout.
	            var nodes = tree.nodes(root).reverse(),
	                links = tree.links(nodes);

	            // Set widths between levels based on maxLabelLength.
	            nodes.forEach(function(d) {
	                d.y = (d.depth * (maxLabelLength * 10)); //maxLabelLength * 10px
	                // alternatively to keep a fixed scale one can set a fixed depth per level
	                // Normalize for fixed-depth by commenting out below line
	                // d.y = (d.depth * 500); //500px per level.
	            });

	            // Update the nodes…
	            node = svgGroup.selectAll("g.node")
	                .data(nodes, function(d) {
	                    return d.id || (d.id = ++i);
	                });

	            // Enter any new nodes at the parent's previous position.
	            var nodeEnter = node.enter().append("g")
	                .attr("class", "node")
	                .attr("transform", function(d) {
	                    return "translate(" + source.y0 + "," + source.x0 + ")";
	                })
	                .on('click', click);

	            nodeEnter.append("circle")
	                .attr('class', 'nodeCircle')
	                .attr("r", 0)
	                .style("fill", function(d) {
	                    return d._children ? "lightsteelblue" : "#fff";
	                });

	            nodeEnter.append("text")
	                .attr("x", function(d) {
	                    return d.children || d._children ? 10 : 10;
	                })
	                .attr("y", function(d) {
	                    return d.children || d._children ? -10 : 0;
	                })
	                .attr("dy", ".35em")
	                .attr('class', 'nodeText')
	                .attr("text-anchor", function(d) {
	                    return d.children || d._children ? "end" : "start";
	                })
	                .text(function(d) {
	                    return d.name;
	                })
	                .style("fill-opacity", 0);

	            // phantom node to give us mouseover in a radius around it
	            nodeEnter.append("circle")
	                .attr('class', 'ghostCircle')
	                .attr("r", 30)
	                .attr("opacity", 0.2) // change this to zero to hide the target area
	            .style("fill", "red")
	                .attr('pointer-events', 'mouseover')
	                .on("mouseover", function(node) {
	                    overCircle(node);
	                })
	                .on("mouseout", function(node) {
	                    outCircle(node);
	                });

	            // Change the circle fill depending on whether it has children and is collapsed
	            node.select("circle.nodeCircle")
	                .attr("r", 4.5)
	                .style("fill", function(d) {
	                    return d._children ? "lightsteelblue" : "#fff";
	                });

	            // Transition nodes to their new position.
	            var nodeUpdate = node.transition()
	                .duration(duration)
	                .attr("transform", function(d) {
	                    return "translate(" + d.y + "," + d.x + ")";
	                });

	            // Fade the text in
	            nodeUpdate.select("text")
	                .style("fill-opacity", 1);

	            // Transition exiting nodes to the parent's new position.
	            var nodeExit = node.exit().transition()
	                .duration(duration)
	                .attr("transform", function(d) {
	                    return "translate(" + source.y + "," + source.x + ")";
	                })
	                .remove();

	            nodeExit.select("circle")
	                .attr("r", 0);

	            nodeExit.select("text")
	                .style("fill-opacity", 0);

	            // Update the links…
	            var link = svgGroup.selectAll("path.link")
	                .data(links, function(d) {
	                    return d.target.id;
	                });

	            // Enter any new links at the parent's previous position.
	            link.enter().insert("path", "g")
	                .attr("class", "link")
	                .attr("d", function(d) {
	                    var o = {
	                        x: source.x0,
	                        y: source.y0
	                    };
	                    return diagonal({
	                        source: o,
	                        target: o
	                    });
	                });

	            // Transition links to their new position.
	            link.transition()
	                .duration(duration)
	                .attr("d", diagonal);

	            // Transition exiting nodes to the parent's new position.
	            link.exit().transition()
	                .duration(duration)
	                .attr("d", function(d) {
	                    var o = {
	                        x: source.x,
	                        y: source.y
	                    };
	                    return diagonal({
	                        source: o,
	                        target: o
	                    });
	                })
	                .remove();

	            // Stash the old positions for transition.
	            nodes.forEach(function(d) {
	                d.x0 = d.x;
	                d.y0 = d.y;
	            });
	        }

	        // Append a group which holds all nodes and which the zoom Listener can act upon.
	        var svgGroup = baseSvg.append("g");

	        // Define the root
	        root = treeData;
	        root.x0 = viewerHeight / 2;
	        root.y0 = 0;

	        // Layout the tree initially and center on the root node.
	        update(root);
	        centerNode(root);
	    });
  </script>
</body>
</html>
